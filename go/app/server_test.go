package app

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"

	"github.com/golang/mock/gomock"
)

func TestParseAddItemRequest(t *testing.T) {
	t.Parallel() // methods for running test functions in parallel

	type wants struct {
		req *AddItemRequest
		err bool
	}

	imageBytes, err := os.ReadFile("../cmd/api/images/basket.jpg")
	if err != nil {
		t.Fatalf("failed to read default image: %v", err)
	}

	// STEP 6-1: define test cases
	cases := map[string]struct {
		args map[string][]byte
		wants
	}{
		"ok: valid request": {
			args: map[string][]byte{
				//data included in the body of an HTTP request is often treated as binary data ([]byte).
				"name":       []byte("sample_name"),     // fill here
				"category":   []byte("sample_category"), // fill here
				"image_name": imageBytes,
			},
			wants: wants{
				req: &AddItemRequest{
					Name:     "sample_name",     // fill here
					Category: "sample_category", // fill here
					Image:    imageBytes,
				},
				err: false,
			},
		},

		// step6-1
		// if any one is missing, an error will be issued
		"ng: missing name": {
			args: map[string][]byte{
				"category":   []byte("sample_category"),
				"image_name": imageBytes,
			},
			wants: wants{
				req: nil,
				err: true, // Error due to missing Name
			},
		},
		"ng: missing category": {
			args: map[string][]byte{
				"name":       []byte("sample_name"),
				"image_name": imageBytes,
			},
			wants: wants{
				req: nil,
				err: true, //Error due to missing Category
			},
		},
		"ng: missing image": {
			args: map[string][]byte{
				"name":     []byte("sample_name"),
				"category": []byte("sample_category"),
			},
			wants: wants{
				req: nil,
				err: true, // Error due to missing Image
			},
		},
		"ng: empty request": {
			args: map[string][]byte{},
			wants: wants{
				req: nil,
				err: true, // Error due to request is empty
			},
		},
	}

	// convert to a multipart HTTP request body
	for name, tt := range cases {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			var body bytes.Buffer
			w := multipart.NewWriter(&body)

			// prepare request body
			// k is a field name like "name"or "category", v is "sample_name", "sample_category"
			for k, v := range tt.args {
				if k == "image_name" {
					// if k is "image", add image file to multipart/form-data
					fw, err := w.CreateFormFile("image", "basket.jpg")
					if err != nil {
						t.Fatal(err)
					}
					if _, err := fw.Write(v); err != nil {
						t.Fatal(err)
					}
				} else {
					if err := w.WriteField(k, string(v)); err != nil {
						t.Fatal(err)
					}
				}
			}
			contentType := w.FormDataContentType() //Gets the value of the Content-Type header that is automatically generated by multipart
			w.Close()                              // complete  writing multipart/form-data

			req, err := http.NewRequest("POST", "/items", &body)
			req.Header.Set("Content-Type", contentType)

			// execute test target
			got, err := parseAddItemRequest(req)

			// Confirm the result
			if err != nil && !tt.wants.err {
				t.Fatalf("expected no error, but got: %v", err)
			}
			if err == nil && tt.wants.err {
				t.Fatal("expected error, but got none")
			}

			// Compare the result, handling []byte comparison
			if !tt.wants.err {
				if got.Name != tt.wants.req.Name {
					t.Errorf("expected Name: %s, got: %s", tt.wants.req.Name, got.Name)
				}
				if got.Category != tt.wants.req.Category {
					t.Errorf("expected Category: %s, got: %s", tt.wants.req.Category, got.Category)
				}
				if !bytes.Equal(got.Image, tt.wants.req.Image) {
					t.Errorf("expected Image: %#v, got: %#v", tt.wants.req.Image, got.Image)
				}
			}
		})
	}
}

func TestHelloHandler(t *testing.T) {
	t.Parallel()

	// Please comment out for STEP 6-2
	// predefine what we want
	type wants struct {
		code int               // desired HTTP status code
		body map[string]string //desired body
	}
	want := wants{
		code: http.StatusOK,
		body: map[string]string{"message": "Hello, world!"},
	}

	// set up test
	req := httptest.NewRequest("GET", "/hello", nil)
	res := httptest.NewRecorder()

	h := &Handlers{}
	h.Hello(res, req)

	// STEP 6-2: confirm the status code
	if res.Code != want.code {
		t.Errorf("want %d, but %d", want.code, res.Code)
	}
	// STEP 6-2: confirm response body
	var got HelloResponse
	err := json.NewDecoder(res.Body).Decode(&got) // store the response body
	if err != nil {
		t.Fatalf("failed to decode response body: %v", err)
	}
	// check if the response is as expected
	if got.Message != want.body["message"] {
		t.Errorf("want message %q,but got %q", want.body["message"], got.Message)
	}

}

func TestAddItem(t *testing.T) {
	t.Parallel()

	type wants struct {
		code int
	}
	cases := map[string]struct {
		args     map[string]string
		injector func(m *MockItemRepository)
		wants
	}{
		"ok: correctly inserted": {

			args: map[string]string{
				"name":       "used iPhone 16e",
				"category":   "phone",
				"image_name": "test.jpg",
			},
			injector: func(m *MockItemRepository) {
				// STEP 6-3:
				// gomock.Any→ any argument(任意の型の引数)
				// gomock.AssignableToTypeOf(&Item{})→　The second argument of the Insert method is of type Item (Item型ならなんでもいい)
				m.EXPECT().Insert(gomock.Any(), gomock.AssignableToTypeOf(&Item{})).Return(nil).Times(1)
				// succeeded to insert
			},
			wants: wants{
				code: http.StatusOK,
			},
		},
		// image doesn't matter
		//  画像の有無に関わらずInsertメソッドが失敗することを模擬している
		"ng: failed to insert": {
			args: map[string]string{
				"name":     "used iPhone 16e",
				"category": "phone",
			},
			injector: func(m *MockItemRepository) {
				// STEP 6-3: define mock expectation
				// set Insert method to fail
				m.EXPECT().Insert(gomock.Any(), gomock.AssignableToTypeOf(&Item{})).
					Return(fmt.Errorf("insert failed")).Times(1)

			},
			wants: wants{
				code: http.StatusInternalServerError,
			},
		},
	}
	// convert to a multipart HTTP request body
	// use dummy image data instead of an actual image data
	for name, tt := range cases {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockIR := NewMockItemRepository(ctrl)
			tt.injector(mockIR)
			h := &Handlers{repo: mockIR}

			var body bytes.Buffer
			w := multipart.NewWriter(&body)

			for k, v := range tt.args {
				if k == "image_name" {
					// set the image data
					fw, err := w.CreateFormFile("image", v)
					if err != nil {
						t.Errorf("failed to create form file: %v", err)
					}
					_, err = fw.Write([]byte("dummy image data"))
					if err != nil {
						t.Errorf("failed to write image data: %v", err)
					}
				} else {
					w.WriteField(k, v)
				}
			}
			w.Close()

			req := httptest.NewRequest("POST", "/items", &body)
			req.Header.Set("Content-Type", w.FormDataContentType())

			rr := httptest.NewRecorder()
			h.AddItem(rr, req)

			if tt.wants.code != rr.Code {
				t.Errorf("expected status code %d, got %d", tt.wants.code, rr.Code)
			}
			if tt.wants.code >= 400 {
				return
			}

		})
	}
}

// STEP 6-4: uncomment this test
func TestAddItemE2e(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping e2e test")
	}

	db, closers, err := setupDB(t)
	if err != nil {
		t.Fatalf("failed to set up database: %v", err)
	}
	t.Cleanup(func() {
		for _, c := range closers {
			c()
		}
	})

	type wants struct {
		code int
	}
	cases := map[string]struct {
		args map[string][]byte
		wants
	}{
		"ok: correctly inserted": {
			args: map[string][]byte{
				"name":       []byte("used iPhone 16e"),
				"category":   []byte("phone"),
				"image_name": []byte("fake image data"),
			},
			wants: wants{
				code: http.StatusOK,
			},
		},
		"ng: failed to insert": {
			args: map[string][]byte{
				"name":       []byte(""),
				"category":   []byte("phone"),
				"image_name": []byte("fake image data"),
			},
			wants: wants{
				code: http.StatusBadRequest,
			},
		},
	}

	for name, tt := range cases {
		t.Run(name, func(t *testing.T) {
			h := &Handlers{repo: &itemRepository{db: db}}

			// create a multipart/form-data request
			var buf bytes.Buffer
			writer := multipart.NewWriter(&buf)
			for k, v := range tt.args {
				if k == "image_name" {
					part, err := writer.CreateFormFile("image", "test.jpg")
					if err != nil {
						t.Fatalf("failed to create form file: %v", err)
					}
					part.Write(v) // write the image data
				} else {
					writer.WriteField(k, string(v))
				}
			}
			writer.Close()

			// make an HTTP request
			req := httptest.NewRequest("POST", "/items", &buf)
			req.Header.Set("Content-Type", writer.FormDataContentType())

			rr := httptest.NewRecorder()
			h.AddItem(rr, req)

			// check response
			if tt.wants.code != rr.Code {
				t.Errorf("expected status code %d, got %d", tt.wants.code, rr.Code)
			}
			if tt.wants.code >= 400 {
				return
			}

			// STEP 6-4: check inserted data
			item := &Item{}
			err = db.QueryRow(`
    		SELECT items.name, categories.name, items.image_name
   		    FROM items
    		JOIN categories ON items.category_id = categories.id
    		WHERE items.name = ?`, string(tt.args["name"]),
			).Scan(&item.Name, &item.Category, &item.Image)

			if err != nil {
				t.Errorf("failed to query inserted item: %v", err)
			}

			//verify that the inserted item matches the expected values
			if item.Name != string(tt.args["name"]) {
				t.Errorf("expected item name to be %s,got %s", tt.args["name"], item.Name)
			}
			if item.Category != string(tt.args["category"]) {
				t.Errorf("expected item category to be %s, got %s", tt.args["category"], item.Category)
			}
			if item.Image != "5b3397652358a6663a0225ee76466d4e4fd6c58d484d1aa25170bb617d6bb086.jpg" {
				t.Errorf("expected item image to be %s, got %s", "5b3397652358a6663a0225ee76466d4e4fd6c58d484d1aa25170bb617d6bb086.jpg", item.Image)
			}

		})
	}
}

func setupDB(t *testing.T) (db *sql.DB, closers []func(), e error) {
	t.Helper()

	defer func() {
		if e != nil {
			for _, c := range closers {
				c()
			}
		}
	}()

	originalDB := "../db/items.db"
	// copy items.db
	testDB := "../db/items_test.db"

	input, err := os.ReadFile(originalDB)
	if err != nil {
		return nil, nil, err
	}
	err = os.WriteFile(testDB, input, 0644)
	if err != nil {
		return nil, nil, err
	}

	db, err = sql.Open("sqlite3", testDB)
	if err != nil {
		return nil, nil, err
	}

	closers = append(closers, func() {
		db.Close()
		os.Remove(testDB)
	})

	return db, closers, nil
}
